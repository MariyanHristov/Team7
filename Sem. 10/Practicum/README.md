## Задачи

### Задача 1:
Как можем да наблюдаваме абсолютно всяка промяна в стойността на дадена променлива и да я логнем в конзолата например?

Напишете шаблон за клас Observable<T> с:

- Конструктор Observable(const T&); - запазва стойността на подадения параметър в private поле.
- Селектор T getValue() const; -  връща копие на запазената стойност
- Мутатор void setValue(const T&); - освен да присвоява новата стойност, прави още две неща:
  - Точно преди да присвои стойността отпечатва на конзолата Will set value from {старата стойност} to {новата стойност}
  - Точно след като присвои стойността отпечатва на конзолата Did set value from {старата стойност} to {новата стойност}

### Задача 2:
Реализирайте клас наредена двойка (Pair), който съдържа две променливи от произволен тип. Напишете конструктор с параметри, get-ъри и set-ъри за атрибутите на класа, както и метод, който връща максималния елемент от наредената двойка. Предефинирайте операторите == и != за Pair.

Бонус: Модифицирайте Pair да работи и с две променливи от произволни различни типове.
	    
### Задача 3:
Реализирайте структурата от данни **Vector**. 
Структурата трябва да осигурява достъп до произволен елемент, както и добавяне и премахване на елемент на произволна позиция.

Реализирайте следните член-функции:
  1. pushBack(..)
  2. pushAt(..)
  3. popBack(..)
  4. popAt(..)
  5. operator[]
  6. empty(..)
  7. clear(..)
  8. swap(..)

Реализирайте и други подходящи функции.
  
### Задача 4:
Релизирайте структурата от данни опашка. Опашката трябва да работи с **произволни типове**. След като е добавен един елемент в края на опашката, той ще може да бъде извлечен (премахнат) единствено след като бъдат премахнати всички елементи преди него в реда, в който са добавени.

```c++
int main()
{
	quene<int> q;
	q.enqueue(3);
	q.enqueue(5);
	q.enqueue(10);

	cout << q.dequeue() << endl; //3
	cout << q.dequeue() << endl; //5
	cout << q.dequeue() << endl; //10

	cout << q.isEmpty() << endl; //1	
}
```

### Задача 5:
 Създайте **шаблонна** опашка с k приоритета. При взимане на елемент от опашката трябва да се връща най-отдавна добавения елемент от тези с най-висок приоритет.
 
```c++
int main()
{
	kPriorityQueue<char> q(4); // 4 priorities - 0, 1, 2 и 3.
	
	q.enqueue('A',0): //adds A with lowest priority: 0
	q.enqueue('B',3);
	q.enqueue('C',2);
	q.enqueue('D',2);
	q.enqueue('E',1);
	
	//q.enqueue('F', 5); //error! No such priority!
	
	q.dequeue(); // B
	q.dequeue(); // C
	q.dequeue(); // D
	q.dequeue(); // E
	q.dequeue(); // A
}
 ```
	
## Useful information
- [std::pair](https://www.cplusplus.com/reference/utility/pair/pair/)
- [std::vector](https://www.cplusplus.com/reference/vector/vector/?kw=vector)
- [std::queue](https://www.cplusplus.com/reference/queue/queue/?kw=queue)
- [std::priority_queue](https://www.cplusplus.com/reference/queue/priority_queue/?kw=priority_queue)
